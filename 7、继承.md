# 继承

- 使得子类具有父类的属性和方法
- 可以在子类中重新定义，追加属性和方法
- 好处：提高代码复用性和维护性
- 坏处：类的耦合性增强，削弱子类独立性
- 符合is a关系 苹果-水果 猫-动物
- Java单继承

```java
public class Student extends Person{
	pass;
}
```

## 继承成员与访问

**除了static成员，构造方法**，
子类会继承父类中其它所有的成员，包括private的成员【虽然无法直接访问】。
访问属性决定了子类可以访问从父类继承的哪些成员。

| 父类的访问属性 | 同一个包 | 不同包 |
| -------------- | -------- | ------ |
| private        | **N**    | **N**  |
| 默认           | Y        | **N**  |
| protected      | Y        | Y      |
| public         | Y        | Y      |

###继承中变量的访问特点
1. 子类局部范围找（方法中定义的变量）
2. 子类成员范围找
3. 父类成员范围找

###super
this：本类对象引用
super：父类存储空间的标识
super作用：
- 调用被隐藏的父类成员变量与成员方法【子类可能重新定义了某些变量与方法
- 调用父类构造方法

![image-20200203144408821](C:\Users\Hery\Desktop\GitHub\java\image\image-20200203144408821.png)

###继承中构造方法的访问特点
注意：子类中所有的构造方法默认都会访问==父类中无参的构造方法==  

子类初始化之前，一定要先完成父类数据的初始化

如果在子类的构造方法中，没有显示地利用**super(参数)**调用父类的构造方法，那么会在子类的构造方法中**第一条语句**处，自动插入一条**super()**语句来调用父类的构造方法。

如果父类没有无参构造方法：
1. 通过使用super关键字去显示的调用父类的带参构造方法
2. 在父类中自己提供一个无参构造方法【推荐】

###继承中成员方法的访问特点
通过子类对象访问一个方法
1. 子类成员范围找
2. 父类成员范围找

###重载与重写

成员方法的重载(overloading)：扩展父类的方法。 
	子类定义了与父类具有同名，但是参数不同（数目或类型)的成员方法

成员方法的重写(override)：覆盖父类的方法。 
	子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）
@override注解

1. 私有方法不能被重写(父类私有成员子类是不能继承的)
2. 子类方法访问权限不能更低(public > 默认 > 私有)

### 内存分配

####类的内存分配【方法区】

![image-20200204105021507](C:\Users\Hery\Desktop\GitHub\java\image\image-20200204105021507.png)

#### 对象的内存分配

![image-20200204105529921](C:\Users\Hery\Desktop\GitHub\java\image\image-20200204105529921.png)



# 修饰符

### package

文件夹，多级表示：package com.heima.demo;  

带包编译：javac –d . 类名.java
例如：javac -d . com.heima.demo.HelloWorld.java
带包运行：java 包名+类名
例如：java com.heima.demo.HelloWorld  

### import

import java.util.Scanner;  

### final

- fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）
- final修饰方法：该方法不能被重写
- final修饰变量：表明该变量是一个常量，不能再次赋值

### static

1. 被类的所有对象共享，这也是我们判断是否使用静态关键字的条件
2. 可以通过类名调用当然，也可以通过对象名调用【推荐使用类名调用】
3. 静态成员方法只能访问静态成员

