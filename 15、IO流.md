#流
流:具有 **数据源** 和 **数据目的地** 的字节序列形式的抽象表示。

<img src="C:\Users\Hery\Desktop\GitHub\java\image\image-20200226152924759.png" alt="image-20200226152924759" style="zoom:67%;" />

- 输入流：抽象多种不同类型的输入。
  磁盘文件、键盘(标准输入)、网络套接字(socket)等
- 输出流：抽象多种不同类型的输出。
  磁盘文件、显示器（标准输出）、网络套接字(socket)等

缓冲流：为流配备一个缓冲区（buffer)，提高数据的传输效率

<img src="C:\Users\Hery\Desktop\GitHub\java\image\image-20200226175535879.png" alt="image-20200226175535879" style="zoom:67%;" />

| 类 | 描述 |
| ------------ | -------------------------- |
| InputStream  | **字节流**输入操作的抽象类 |
| OutputStream | **字节流**输出操作的抽象类 |
| Reader       | **字符流**输入操作的抽象类 |
| Writer       | **字符流**输出操作的抽象类 |

# 字节流（binary stream）

![image-20200223103958730](C:\Users\Hery\Desktop\GitHub\java\image\image-20200223103958730.png)

##FileOutputStream写数据

使用字节输出流写数据的步骤

1. 创建字节输出流对象(创建文件，创建字节输出流对象，让字节输出流对象指向文件)
2. 调用字节输出流对象的写数据方法

| 方法名                                 | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| void write(int b)                      | 将一个整数输出到流中（**只输出低位一个字节**）               |
| void write(byte[] b)                   | 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 |
| void write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一 次写一个字节数组的部分数据 |

3. 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)  

- 字节流写数据换行：
  **windows:\r\n**
  **linux:\n**
  mac:\r  

- ==追加写入-构造方法
  public FileOutputStream(String name,**boolean append**) 置true==

## FileInputStream读数据

1. 创建字节输入流对象
2. 调用字节输入流对象的读数据方法

- int read() : 
  从输入流中读一个字节，==低字节是读取的内容，高字节全是0==。 
  返回一个0～ 255之间的整数。-1为文件结束。      
  
- int read(byte[] buffer) :
  读多个字节到数组中。
  从输入流中读取字节序列并将它们存放到字节数组buffer中，直到buffer填满为止。
  返回读取的字节数目。 

3. 释放资源

```java
public static void f1() throws IOException {
        FileInputStream fis=new FileInputStream("C:\\itcast\\字节流复制图片.avi");
        FileOutputStream fos=new FileOutputStream("myByteStream\\字节流复制图片.avi");
        int by;
        while((by=fis.read())!=-1){
            fos.write(by);
        }
        fis.close();
        fos.close();
    }
```

```java
public static void f2() throws IOException {
        FileInputStream fis=new FileInputStream("C:\\itcast\\字节流复制图片.avi");
        FileOutputStream fos=new FileOutputStream("myByteStream\\字节流复制图片.avi");
        byte[] bys=new byte[1024];
        int len;
        while((len=fis.read(bys))!=-1){
            fos.write(bys,0,len);
        }
        fis.close();
        fos.close();
    }
```

## 字节缓冲流

### BufferedOutputStream

###BufferedInputStream

| 方法名                                 | 说明                   |
| -------------------------------------- | ---------------------- |
| BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |
| BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |

```java
public static void f3() throws IOException {
    BufferedInputStream bis=new BufferedInputStream(new FileInputStream("C:\\itcast\\字节流复制图片.avi"));
    BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("myByteStream\\字节流复制图片.avi"));
    int by;
    while((by=bis.read())!=-1){
        bos.write(by);
    }
    bis.close();
    bos.close();
}
```
==一般采用以下：缓冲流+字节数组==

```java
public static void f4() throws IOException {
    BufferedInputStream bis=new BufferedInputStream(new FileInputStream("C:\\itcast\\字节流复制图片.avi"));
    BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("myByteStream\\字节流复制图片.avi"));
    byte[] bys=new byte[1024];
    int len;
    while((len=bis.read())!=-1){
        bos.write(bys,0,len);
    }
    bis.close();
    bos.close();
}
```

# 字符流（character stream）

![image-20200223104137111](C:\Users\Hery\Desktop\GitHub\java\image\image-20200223104137111.png)

字符流 = 字节流 + 编码表（操作中文）

字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接
成中文，如何识别是中文的呢？
汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 。

##编码表

**GBK：**最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了
21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等  

**Unicode字符集：**
UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用
中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用
一至四个字节为每个字符编码
编码规则：
128个US-ASCII字符，只需一个字节编码
拉丁文等字符，需要二个字节编码
大部分常用字（含中文），使用三个字节编码
其他极少使用的Unicode辅助字符，使用四字节编码  

##字符串&字节数组

| 方法名                                   | 说明                                               |
| ---------------------------------------- | -------------------------------------------------- |
| byte[] getBytes()                        | 使用平台的默认字符集将该 String编码为一系列字节    |
| byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String编码为一系列字节        |
| String(byte[] bytes)                     | 使用平台的默认字符集解码指定的字节数组来创建字符串 |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串     |

例如，“中国”

“GBK"[-42, -48, -71, -6]  

默认"UTF-8"[-28, -72, -83, -27, -101, -67]  

##字符流编解码

### InputStreamReader：

字节流→字符流
它读取字节，并使用指定的编码将其解码为字符
它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集

###OutputStreamWriter：

字符流→字节流
使用指定的编码将写入的字符编码为字节
它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集  

| 方法名                                              | 说明                                          |
| --------------------------------------------------- | --------------------------------------------- |
| InputStreamReader(InputStream in)                   | 使用默认字符编码创建InputStreamReader对 象    |
| InputStreamReader(InputStream in,String chatset)    | 使用指定的字符编码创建InputStreamReader 对象  |
| OutputStreamWriter(OutputStream out)                | 使用默认字符编码创建OutputStreamWriter对 象   |
| OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter 对象 |

```java
OutputStreamWriter osw= new OutputStreamWriter(
    new FileOutputStream("myCharStream\\osw.txt"),"GBK"
);
osw.write("中国");
osw.close();

InputStreamReader isr=new InputStreamReader(
    new FileInputStream("myCharStream\\osw.txt"),"GBK"
);
int ch;
while((ch=isr.read())!=-1){
    System.out.print((char)ch);
}
isr.close();
```

##字符流写数据的5种方式

| 方法名                                    | 说明                 |
| ----------------------------------------- | -------------------- |
| void write(int c)                         | 写一个字符           |
| void write(char[] cbuf)                   | 写入一个字符数组     |
| void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |
| void write(String str)                    | 写一个字符串         |
| void write(String str, int off, int len)  | 写一个字符串的一部分 |

##刷新和关闭的方法

| 方法名  | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| flush() | 刷新流，之后还可以继续写数据                                 |
| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

##字符流读数据的2种方式

| 方法名                | 说明                   |
| --------------------- | ---------------------- |
| int read()            | 一次读一个字符数据     |
| int read(char[] cbuf) | 一次读一个字符数组数据 |

##便捷流

字符流子类（默认字符编码和默认字节缓冲区大小），使用方法一样

### FileReader

###FileWriter

## 字符缓冲流

| 方法名                     | 说明                   |
| -------------------------- | ---------------------- |
| BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |
| BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |
参数方便可用FileReader和FileWriter
### BufferedWriter

| 方法名         | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义，兼容win、linux、mac |

###BufferedReader

| 方法名            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经 到达，则为null |

#字符流复制方法

==缓冲流+特有方法==

```java
BufferedReader br=new BufferedReader(new FileReader("myCharStream\\src\\Demo4.java"));
BufferedWriter bw=new BufferedWriter(new FileWriter("myCharStream\\Copy4.java"));
String line;
while((line=br.readLine())!=null){
    bw.write(line);
    bw.newLine();
    bw.flush();
}
bw.close();
br.close();
```

#复制多级文件夹

```java
public class Demo {
    public static void main(String[] args) throws IOException {
        File srcFile=new File("C:\\itcast");
        File destFile = new File("myCharStream\\src\\复制多级文件夹");
        copyFolder(srcFile,destFile);
    }
    //复制文件夹
    /*
    1、由于是递归方法，先判断srcFile是目录还是文件，是文件直接复制
    2、是目录的话，在destFile创建目录
    3、获取文件夹下File数组
    4、遍历并递归
    */
    private static void copyFolder(File srcFile, File destFile) throws IOException {
        if(srcFile.isDirectory()){
            File newFolder=new File(destFile,srcFile.getName());//public class Demo {
    public static void main(String[] args) throws IOException {
        File srcFile=new File("C:\\itcast");
        File destFile = new File("myCharStream\\src\\复制多级文件夹");
        copyFolder(srcFile,destFile);
    }
    //复制文件夹
    /*
    1、由于是递归方法，先判断srcFile是目录还是文件，是文件直接复制
    2、是目录的话，在destFile下创建目录
    3、获取文件夹下File数组
    4、遍历并递归
    */
    private static void copyFolder(File srcFile, File destFile) throws IOException {
        if(srcFile.isDirectory()){
            File newFolder=new File(destFile,srcFile.getName());
            if(!newFolder.exists()){
                newFolder.mkdirs();
            }
            File[] fileArray = srcFile.listFiles();
            for(File f:fileArray){
                copyFolder(f,newFolder);
            }
        }else{
            copyFile(srcFile,new File(destFile,srcFile.getName()));
        }
    }
    //字节缓冲流复制文件
    private static void copyFile(File srcFile, File destFile) throws IOException {
        BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(destFile));
        BufferedInputStream bis=new BufferedInputStream(new FileInputStream(srcFile));
        byte[] bys=new byte[1024];
        int len;
        while((len=bis.read(bys))!=-1){
            bos.write(bys,0,len);
        }
        bos.close();
        bis.close();

    }
}
            if(!newFolder.exists()){
                newFolder.mkdirs();
            }
            File[] fileArray = srcFile.listFiles();
            for(File f:fileArray){
                copyFolder(f,newFolder);
            }
        }else{
            copyFile(srcFile,new File(destFile,srcFile.getName()));
        }
    }
    //字节缓冲流复制文件
    private static void copyFile(File srcFile, File destFile) throws IOException {
        BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(destFile));
        BufferedInputStream bis=new BufferedInputStream(new FileInputStream(srcFile));
        byte[] bys=new byte[1024];
        int len;
        while((len=bis.read(bys))!=-1){
            bos.write(bys,0,len);
        }
        bos.close();
        bis.close();

    }
}
```
#异常处理
##基本做法

```java
FileOutputStream fos=null;
try{
    fos=new FileOutputStream("Z:\\myByteStream\\fos.txt",true);
    fos.write("abcde".getBytes(),1,3);
}catch(IOException e){
    e.printStackTrace();
}finally{
    try{
        fos.close();
    }catch(IOException e){
        e.printStackTrace();
    }
}
```

##JDK7（首选）

- try（流对象创建）

- 省略close()

```java
private static void method3() {
        try (FileReader fr = new FileReader("fr.txt");
             FileWriter fw = new FileWriter("fw.txt");) {
            char[] chs = new char[1024];
            int len;
            while ((len = fr.read()) != -1) {
                fw.write(chs, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

## JDK9

```java
private static void method4() throws IOException {
    FileReader fr = new FileReader("fr.txt");
    FileWriter fw = new FileWriter("fw.txt");
    try(fr;fw){
        char[] chs = new char[1024];
        int len;
        while ((len = fr.read()) != -1) {
            fw.write(chs, 0, len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```